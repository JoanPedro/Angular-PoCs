Gerar novos módulos:

- ng g m Module_Name --routing ( --routing: Permite que o módulo seja roteado.)
( Routed Modules ).

  - A partir do momento que o Angular cria o Routed Modules, ele cria dentro do
  módulo solicitado o Routing Module (Module_Name-routing.module.ts)

Tipos de módulos:

-> Domain: Agrupa todos os componentes necessários para implementar uma única feature;
-> Routed: Semelhante ao módulo 'Domain', mas esses componentes estão vinculados
às rotas (exibidas apenas quando o usuário está em um endereço específico);
-> Routing: Define regras de rotas (Ex: mostre o componente Todo List quando
um usuário estiver em uma rota de '/ todos');
-> Services: Define Services que serão utilizados in diversas partes da aplicação;
-> Widget: Define alguns componentes reutilizáveis que serão utilizados em multiplos
outros componentes.

Estratégia:
- Cada Módulo deve possuir seus componentes, e o componente Pai (app Module) deve
renderizar todos eles.
- Componentes dentro de módulos específicos só podem ser acessados pelos próprios
módulos. Para ser acessado por outros módulos e externamente, é necessários exportar
os componentes a partir do seu módulo (Simplesmente exportar e importar dentro do App Module ou
qualquer outro 'Módulo'. Ou, ao invés de exportar, definir um component roteado, e a partir do
'componentNome-Routing-Module' definir dentro de suas Rotas o Path ('/nomeDaRota') que será atribuido e
qual componente será definido para ele).

Propriedades:

-> Declartions: Lista de componentes, pipes, diretivas que são criadas neste módulo.
-> Imports: Lista de outros módulos que este 'módulo' depende uma vez.
-> Exports: Lista de componentes, pipes, diretivas que este 'módulo' torna "público/disponível"
para fora, ou seja, para serem utilizados em outros módulos.
-> Providers: Caminho ANTIGO para conecção de módulos e serviços.
-> Bootstrap: Usado pelo AppModule somente para declarar qual componente irá mostrar primeiro.

Routing:

-> Para rotear um componente e ser acessível somente em uma específica rota, é necessário
realizar o roteamento dele dentro do seu componente de rotas, definindo: path e componente que será renderizado.
Ex. path: 'element', component: ElementComponent. Desta forma, o component ElementComponent será
renderizado a partir da rota /element.

________________________________________________________________________________

Overview:

- Módulo Pai: AppModule
  Componente do Módulo Pai: AppComponent

- Módulos Filhos: ElementsModule e CollectionsModule
  Componentes dos Módulos Filhos: ElementsHomeComponent e CollectionsHomeComponent
    - Roteamento (Elements/Collections Routing Module)
      path: 'elements', component: 'ElementsComponent'
      path: 'collections', component: 'CollectionsComponent'

Ou seja:

1. ElementsModule (Possui um ElementHomeComponent e um ElementsRouting)
2. ElementsRouting Module define o path (página que será disponibilizado '/elements' e
também qual component será renderizado: ElementComponent.)
3. No AppComponent (Component PAI) define um '<route-outlet></route-outlet>' que será o responsável
por exibir os componentes definidos nos respectivos Routing Module.
4. No AppModule.ts Importa o devido Módulo e define ele no @ngModule.

--

routerLink -> Ao invés de href para navegar entre componentes roteados.
routerLinkActive -> Para fazer a marcação de qual componente roteado está ativo.

  -> Sobre Roteamento não Lógico:
    - Quando é necessário gerar componentes que não tem sentido ser roteado pela
    lógica de rotas, gera-se componentes sem o sufixo --routing. Desta forma, o Angular
    não vai adicionar automaticamente esses componentes dentro do sistema de rotas. Logo,
    desta forma recomenda-se associar essas rotas dentro do 'app-routing.module.ts'
    -> Então dentro do app-routing.module:
      - Para Home: { path: '', component: HomeComponent }
      - Para NotFound: { path: '**', component: NotFoundComponent }
    -> OBS: Para o funcionamento correto dos componentes com lógica e sem lógia de roteamento,
    é necessário que, dentro do app.module.ts:
      Dentro dos imports, o AppRoutingModule seja o ultima a ser importado. Visto que,
      ele receberá rotas sem lógica. Caso fosse o primeiro, rotas como o NotFound ofuscaria
      todas as outras, sendo sempre renderizado.

________________________________________________________________________________

    -> Roteamento Avançado!

Lazy loading:

- Entrega de renderização de componentes mais leve. O Servidor só enviará dados do componente
necessário e desejado pelo cliente. Muito útil em aplicação mobile, visto que tem condições de
rede reduzidas.
- O problema ocorre uma vez que dentro do App.module.ts, no array 'import' ele chega a importar
todos os componentes que são necessariamente roteados. Desta forma, uma vez que chamado o AppModule
que é necessariamente o módulo pai, ele carregará todos os importe consigo. Logo, é necessário, para
o Lazy loading, retirar os modulos importados dentro do array 'import' (Não considerando os que não
preocisão de lógica de roteamento/path. Que são os casos do PageNotFound e Home!) e realizar uma lógica dentro
de Roteamento que segue:

  -> Escolha quais módulos devem ser tratos com Lazy loader;
  -> Para cada um desses módulos, remova qualquer declaração de importação desses Módulos (Como dentro
  do array de 'import' dentro do AppRoutingModule) de qualquer lugar que esteja no projeto, somente existindo em seus próprio Módulo/Componente;
  -> Em AppRoutingModule, defina a rota em 'routes' array para especificar quando exatamente
    carregar aquele módulo em específico.
  -> Já no seu Módulo de Rotas Lazy Loaded (Módulo de rota do exato componente que está sendo lazy loaded),
    edite o 'path' para cada rota que será relativa ao 'path' que foi especificado em AppRoutingModule.

  No AppRoutingModule:
  {
    path: 'elements', // Nome do caminho que será disponibilizado... (localhost:4200/elements)
    loadChildren: () => import('./elements/elements.module') // Função de Lazy Loading. Que
      .then(module => module.ElementsModule) // importará exatamente o componente Elements quando
      // acessado a rota '/elements'.
  },

  No Módulo de Rotas Lazy loaded, no exemplo ElementsComponent:
  { path: '', component: ElementsHomeComponent}.

    OBS -> Uma vez que no AppRoutingModule esteja definido o path 'elements', não é recomendado,
      que dentro do Módulo de Rotas do componente que está sendo Lazy Loaded, esteja também um
      path, uma vez que as chamadas são cumulativas. Ficando: localhost:4200/elements/elements. Logo,
      faça com que o Módulo de Rotas do Componente que está sendo Lazy Loaded seja definido o path
      somente como: ''. Vazio!


________________________________________________________________________________

 -> Ao invés de utilizar property binds com elementos simples, é possível utilizar
    a diretiva <ng-content /> que irá carregar exatamente o conteúdo especificado
    no módulo compartilhado. Uma alternativa ao @Input e Bindings.
